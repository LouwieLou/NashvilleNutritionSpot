// import for server
const express = require('express');

// import for parsing HTTP requests
const bodyParser = require('body-parser');

// import for generating tokens
const crypto = require('crypto');

// import for square payment generation
const { Client, Environment } = require('square')


// import for reading environment files
const dotenv = require('dotenv');
dotenv.config();
const path = require('path');

// for database connection
const mysql = require("mysql2/promise")
const config = require('../config');

// Set the Access Token for square
const accessToken = process.env.ACCESS_TOKEN


const client = new Client({
  environment: Environment.Sandbox,
  customUrl: 'https://connect.squareupsandbox.com',
  accessToken: accessToken,
})

// Configure OAuth2 access token for square authentication: oauth2
// const oauth2 = client.authentications['oauth2'];
// oauth2.accessToken = accessToken;


// starts an Express.js server at port 4000
const app = express();
const port = 4000;

// uses bodyParser to read http requests, statically serves pages
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(__dirname));

// allows "Cross Origin Requests, from localhost:3000"
// this is the URL for our react app
var cors = require('cors');
const { access } = require('fs');
app.use(cors({
  origin: "http://localhost:3000",
  credentials: true,
}))

// function to query a mySQL database, used in various HTTP routes
async function query(sql, params) {
  // creates a mysql connection
  const connection = await mysql.createConnection(config.db);

  // executes mysql query based on "sql" argument with params as an array input
  const [results, ] = await connection.execute(sql, params, function (err) {
    if (err) {
      throw err;
    }
  });

  return results;
}


// Set 'basePath' to switch between sandbox env and production env
// sandbox: https://connect.squareupsandbox.com
// production: https://connect.squareup.com
// defaultClient.basePath = 'https://connect.squareupsandbox.com';

// test HTTP get route
// to see if your server is running properly, go to 
// http://localhost:3000/test and make sure it prints the message on the browser
app.get('/test', async(req, res) => {
  res.status(200).json({
    "message": "test success"
  })
})


// HTTP POST request to confirm the square payment
app.post('/process-payment', async (req, res) => {
  const request_params = req.body;

  // length of idempotency_key should be less than 45
  const idempotency_key = crypto.randomBytes(22).toString('hex');

  // Charge the customer's card
  const payments_api = client.paymentsApi;

  const request_body = {

    // this is a token generated uniquely for the purchase and can only be used once.
    sourceId: request_params.nonce,

    // this token is generated by a square function in the frontend
    verificationToken: request_params.buyerVerificationToken,
    amountMoney: {
      amount: req.body.amount * 100, // amount to charge generated from frontend
      currency: 'USD'
    },

    // this is a random key of letters/numbers
    idempotencyKey: idempotency_key,
    autocomplete: true,
    orderId: request_params.order_id
  };

  // either completes the payment or sends the error message to frontend.
  try {
    // uses Square API to create the payment based on the variables given in 
    // request_body
    const response = await payments_api.createPayment(request_body);
    res.status(200).json({
      'title': 'Payment Successful',
      'result': 'Success',
    });
  } 
  // error handling
  catch(error) {
    console.log(error)
    res.status(500).json({
      'title': 'Payment Failure',
      'result': "Payment Unsuccessful!!"
    });
  }
  
});

app.post('/create-pay', async (req, res) => {
    const request_params = req.body;

    
    // length of idempotency_key should be less than 45
    const idempotency_key = crypto.randomBytes(22).toString('hex');



    const orders_api = client.ordersApi;

    const order_idempotency_key = crypto.randomBytes(22).toString('hex');
    var bodyOrder = {
    locationId: process.env.LOCATION_ID,
    };  
    bodyOrder.referenceId = 'my-order-001';
    bodyOrder.customerId = 'customer_id8';
    bodyOrder.lineItems = request_params.orderItems.map(item => {
        item.name = item.item_name
        delete item.item_name

        item.quantity = String(item.quantity)
        
        item.basePriceMoney = {
          amount: item.price * 100,
          "currency": "USD"
        }
        return item
      }
    )
    bodyOrder.taxes = [
      {
        "uid": "state-sales-tax",
        "name": "State Sales Tax",
        "percentage": "7",
        "scope": "ORDER"
      }
    ]
  
    bodyOrder.fulfillments = [
        {
          type: "PICKUP",
          state: "PROPOSED",
          pickupDetails: {
            recipient: {
              displayName: `${request_params.firstName} ${request_params.lastName}`,
              note: request_params.note || "No order notes",
              emailAddress: request_params.email,
              phoneNumber: request_params.phone
            },
            expiresAt: request_params.expireTime,
            autoCompleteDuration: "P0DT1H0S",
            scheduleType: "SCHEDULED",
            pickupAt: request_params.pickupTime,
          }
        }
      ]

    const body = {};
    body.order = bodyOrder;
    body.idempotency_key = order_idempotency_key

    
    // either completes the payment or sends the error message to frontend.
    try {
      // uses Square API to create the payment based on the variables given in 
      // request_body
      const order = await orders_api.createOrder(body);
      try {
        // Charge the customer's card
        const payments_api = client.paymentsApi;

        const request_body = {

          // this is a token generated uniquely for the purchase and can only be used once.
          sourceId: request_params.nonce,

          // this token is generated by a square function in the frontend
          verificationToken: request_params.buyerVerificationToken,
          amountMoney: {
          amount: order.result.order.netAmounts.totalMoney.amount, // amount to charge generated from frontend
          currency: 'USD',
          buyerEmailAddress: request_params.email,
          billingAddress: `${request_params.streetAddress} ${request_params.apt || ""} 
          ${request_params.city} ${request_params.state}`

          },
          // this is a random key of letters/numbers
          idempotencyKey: idempotency_key,
          autocomplete: true,
          orderId: order.result.order.id

        };          
        const response = await payments_api.createPayment(request_body);

        res.status(200).json({
            'title': "Order Created, Payment Made",
            "result": "Order/Payment Successful!",
        })
      } catch (error){
        console.log(error)
        res.status(500).json({
          'title': 'Payment Failure',
          'result': "Payment Unsuccessful!!",
          'reason': error.errors
        });
      }

    } 
    // error handling
    catch(error) {
      console.log(error)
      res.status(500).json({
        'title': 'Order Creation Failure',
        'result': "Order Unsuccessful!!",
        'reason': error.errors
      });
    }

})



// HTTP GET request to query the database for the menu items
app.get('/get-menu-items', async (req, res) => {
  const menuArr = await query("SELECT * FROM items")
  if (menuArr) {
    res.status(200).json({
      menuArr
    })
  } else {
    res.status(500).json({
      'title': "Failure to get menu",
      'result': "Menu get unsuccessful!"
    })
  }
})

if (process.env.NODE_ENV === "production") {
  app.use(express.static(path.join(__dirname, "../","../", "frontend", "build")))

  app.get("*", (req, res) => {

      res.sendFile(path.join(__dirname, "../", "../","frontend", "build", "index.html"));

  });
}

const PORT = process.env.PORT || 4000;

app.listen(
  PORT,
  () => console.log(`listening on - http://localhost:${PORT}`)
);
